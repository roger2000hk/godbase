* add idxs.NewSuffix (init with maps.Suffix)
** convert remento name idxs to suffix
** add remento suffix search test after insert

* add remento.Prod
** name

* add remento.Price
** start, end, prod, rc & amnt
** add PriceRcIdx(rc, prod, start)
** add Rc.Prices(cx, start, end) []Price
** add []Price.Calc(rc, start, end) []Price
*** sum parts of prices according to part of total time span on with minute precision
*** break on new prod
*** clear recid in returned recs
*** break if gap between start/end
*** allow overlapping prices
*** add test** add Rc.SumPrices(cx, start, end) []Price

* add basic slice based set in godbase.sets package
** value based like old.Slice
** implement delete/find/insert
** implement Iter for Slice
*** subslice on next
*** return val as key
** add Sorted(...interface{}) constructor

* add sets.Hash
** model on maps.Hash
** use Sorted for slots


* add godbase.dbs package
** add godbase.Db with MapAlloc
** add dbs.Basic
** replaces global MapAlloc in remento
 
* add *Rc.NewResv(start, end, capac) *Resv
** add test

* add *Rc.Update(start, end, total, avail) (big.Rat, error)
** return min of avail / total if total != 0
* add resv test

* add resv loop perf test with unlimited resources

* load settings table to decide amount scale in remento
** create path if it doesn't exist in db.init
** slurp setting tbl if exists
** otherwise init with defaults
** call in remento_test.init()

* add ref test

* rename fix.New to fix.NewInt64
* add fix.NewFloat64
* rename fix.Init to fix.SetBig
* add SetFloat64 / SetInt64
* add fix benchmark based on big.Rat

* add SliceCol
** take col type as param to cols.Slice()

* remento
** add offset idx
** add slice(Ref) col ResvItems

* add MapCol
** take two col types as params to cols.Map()

* implement Dump/Load for idxs.Reverse
** copy tbls

* add Tbl.Delete()

* add remento project
** check old

* add tbls.Wrap

* add Cx
** take cx param in tbl.Insert/Delete
** take cx param in idx.Insert/Delete

* add tbls.Log wrap
* log delete/insert to disk

* add testfn to Delete
** only delete if testfn nil / returns true
** add DeleteAll(key) int

* add ListCol
** base on std list
** take col type as param

* add find loop in both maps in runCutTests

* copy maps to sets package
** no multi capability
** compare perf

* add hash slot resizing

* add sort level resizing

* update poorslab
