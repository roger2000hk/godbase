* change maps.Insert/Delete/Find to return iter to current
** replace Iter.HasNext/HasPrev with Iter.Valid
** update tests

* add testfn to Delete
** rename to DeleteMulti
** only delete if testfn nil / returns true
** add Delete(key) int

* rename Insert to InsertMulti
** add Insert(key, interface{}) bool

* add maps.Any.Set(Key, interface{}) interface{} 
** replaces val update in Insert
** use Insert and update iter val if false

* ---

* add Tbl with cols

* add Rec.Write(Tbl, io.Writer) error
** store nr of cols
** call writeval for all cols

* add Rec.Read(Tbl, io.Reader) error
** load vals into current rec
** load nr of cols & readval for all cols

* add read/write rec test

* add locks package
** copy RW/Ctx from old
*** rename RW to Lock

* add find loop in both maps in runCutTests

* add locks.RWHashMap
** keep one locks.RW per slot

* rename multi_test to full_test

* ---

* add rec support
** Rec interface
** BasicRec wraps maps.Any

* add idx support
** Idx interface
** BasicIdx wraps maps.Any
** provide range ops
*** runs within slot for hash types


* add Any.InsertRange(start, end, MapFn) int
** only ins if mapfn is nil or returns non nil key
** keep insert iter running all the way and call Insert

* add Any.Clone(MapFn)
** panic for embedded imps
** only include elems for which test returns true


* add Any.CutAll(other Any, TestFn)
** return difference as new set
** only move elems for which test returns true
** operate within slot for hash maps

* add Any.Update(start, end, update UpdateFn) int
** type UpdateFn func(k, v) (v, bool)
** delete if bool == false, otherwise update values
** return nr of deleted

* add Any.InsertAll(other Any, TestFn)
** opimized iter insert where possible
*** keep iter around and set to nil if check if next < prev

* copy maps to sets package
** no multi capability
** compare perf
* add locks.Locker
** keep HashMaps of RecId => Lock
*** one for readers, one for writers
** protect maps with Lock 
* add hash resizing
* add skip resizing

* reorg rest of code like hash
