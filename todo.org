* add maps.Any.New()
** return new empty of same type
** add to readme

* add cols.Any.Clone(interface{})

* add Rec.Clone(cs cols.Set) Any
** add cols.Set with EachCol
*** implement for Tbl / Col
** use New() & cols.Clone()
** use in Tbl.Upsert instead of loop

* add Tbl.Len()

* add Tbl.Iter()
** extend maps.Iter


* move recs.IdCol() & recs.CreatedAtCol() to cols
** turn into public vars
** remove fns
** init with init fn
** grab address with &

* add cols.Type interface
** add BasicType
** add Any.ColType() Type
** move Read/Write to Type
** init Basic with type
** try to convert col types to aliases
*** problem with ptr receivers?

* add Tbl.Dump(io.Writer)
** write all recs

* add Tbl.Slurp(io.Writer)
** read until eof

* rename Less to KeyLess in project

* ---

* add testfn to Delete
** only delete if testfn nil / returns true
** add DeleteAll(key) int

* add Tbl.UpsertedAt(Rec) time.Time
** add Basic.upsertedAt
** init to time.Now() in Upsert()

* add Tbl.Revision(Rec) recs.Revision
** init to 1 if not exists, otherwise inc in Upsert()

* add cols.Bool
** add rec methods

* add cols.Bytes
* add cols.Float64


* add Tbl.Delete()

* add tbls.Wrap

* add tbls.Log wrap
** keep []Rec queue
** insert DeleteRec on delete


* add tbls/cols/recs to readme

* ---

* add maps.Any.Clone(start, end, MapFn)
** like Cut, but clone elems

* add find loop in both maps in runCutTests

* add maps.RWHash
** keep one RWMutex per slot

* rename multi_test to full_test

* ---

* add idx support
** Idx interface
** BasicIdx wraps maps.Any
** provide range ops
*** runs within slot for hash types


* add Any.Clone(MapFn)
** panic for embedded imps
** only include elems for which fn returns non nil key

* copy maps to sets package
** no multi capability
** compare perf

* add locks.Locker
** keep HashMaps of RecId => Lock
*** one for readers, one for writers
** protect maps with Lock 

* add hash resizing

* add skip resizing
