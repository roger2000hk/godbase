* correct find result from skip
** commit basic find tests

* add Hash / HashSlots
** one Hash imp
** add HashSlots type for each chain type
*** add GetSlot(i, create) Any method
** init slots lazily in GetSlot()

* add map slot types
** add constructors NewSkipMap & NewESkipMap with maps
*** compare perf

* rename Cut to CutRange
** change to take MapFn instead of TestFn
** add tests

* tune tests

* ---

* add rec support
** Rec interface
** BasicRec wraps maps.Any

* add idx support
** Idx interface
** BasicIdx wraps maps.Any
** provide range ops
*** runs within slot for hash types


* add Any.InsertRange(start, end, MapFn) int
** only ins if mapfn is nil or returns non nil key
** keep insert iter running all the way and call Insert

* add Any.Clone(TestFn)
** panic for embedded imps
** only include elems for which test returns true


* add locks package
** copy RW/Ctx from old
*** rename RW to Lock


* add maps.RWLockHash
** keep one RW.lock per slot


* add Any.CutAll(other Any, TestFn)
** return difference as new set
** only move elems for which test returns true
** operate within slot for hash maps

* add Any.Update(start, end, update UpdateFn) int
** type UpdateFn func(k, v) (v, bool)
** delete if bool == false, otherwise update values
** return nr of deleted

* add Any.InsertAll(other Any, TestFn)
** opimized iter insert where possible
*** keep iter around and set to nil if check if next < prev

* copy maps to sets package
** no multi capability
** compare perf
* add locks.Locker
** keep HashMaps of RecId => Lock
*** one for readers, one for writers
** protect maps with Lock 
