* add locks package
** copy RW/Ctx from old
*** rename RW to Lock

* add locks.RWHashMap
** keep one locks.RW per slot

* add maps.Sorted with First/Last() Iter
** extend Any

* rename Cut to CutRange
** change to take MapFn instead of TestFn
** add tests

* ---

* add rec support
** Rec interface
** BasicRec wraps maps.Any

* add idx support
** Idx interface
** BasicIdx wraps maps.Any
** provide range ops
*** runs within slot for hash types


* add Any.InsertRange(start, end, MapFn) int
** only ins if mapfn is nil or returns non nil key
** keep insert iter running all the way and call Insert

* add Any.Clone(MapFn)
** panic for embedded imps
** only include elems for which test returns true


* add Any.CutAll(other Any, TestFn)
** return difference as new set
** only move elems for which test returns true
** operate within slot for hash maps

* add Any.Update(start, end, update UpdateFn) int
** type UpdateFn func(k, v) (v, bool)
** delete if bool == false, otherwise update values
** return nr of deleted

* add Any.InsertAll(other Any, TestFn)
** opimized iter insert where possible
*** keep iter around and set to nil if check if next < prev

* copy maps to sets package
** no multi capability
** compare perf
* add locks.Locker
** keep HashMaps of RecId => Lock
*** one for readers, one for writers
** protect maps with Lock 
* add hash resizing
* add skip resizing

* reorg rest of code like hash
